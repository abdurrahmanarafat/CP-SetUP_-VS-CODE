{
    "CP Main Template": {
        "prefix": "cp",
        "body": [
            "import java.util.*;",
			"import java.io.BufferedReader;",
            "import java.io.IOException;",
            "import java.io.InputStreamReader;",
            "import java.io.PrintWriter;",
            "import java.util.ArrayList;",
            "import java.util.Arrays;",
            "import java.util.Collections;",
            "import java.util.Random;",
            "import java.util.StringTokenizer;",
            "",
            "public class ${TM_FILENAME_BASE} {",
            "    static final int MAX_N = 100005;",
            "    static final long MOD = 1000000007;",
            "    static final long INF = 1000000000;",
            "    static final double EPS = 1e-9;",
            "",
            
            "    public static void main(String[] args) {",
            "    FastScanner fs = new FastScanner();",
            "    PrintWriter out = new PrintWriter(System.out);",

            "        int tc = 1;",
            "        // tc = fs.nextInt();",
            "        for (int t = 1; t <= tc; t++) {",
            "            // System.out.printf(\"Case #%d: \", t);",
            "            ",
            "        }",
            "        out.close();",
            "    }",
            "}"
        ],
        "description": "CP Main Template"
    },
    "Debugger Template": {
        "prefix": "debug",
        "body": [
            "public static void debug(Object... args) {",
            "    System.err.println(Arrays.deepToString(args));",
            "}"
        ],
        "description": "Debugger Template"
    },
    "Randomiser": {
        "prefix": "rand",
        "body": [
            "static Random rng = new Random();",
            "static long rand(long l, long r) {",
            "    return l + rng.nextLong(r - l + 1);",
            "}"
        ],
        "description": "Randomiser"
    },
    "Fast Scanner": {
        "prefix": "fastscanner",
        "body": [
            "static class FastScanner {",
            "    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));",
            "    StringTokenizer st = new StringTokenizer(\"\");",
            "",
            "    String next() {",
            "        while (!st.hasMoreTokens())",
            "            try {",
            "                st = new StringTokenizer(br.readLine());",
            "            } catch (IOException e) {",
            "                e.printStackTrace();",
            "            }",
            "        return st.nextToken();",
            "    }",
            "",
            "    int nextInt() {",
            "        return Integer.parseInt(next());",
            "    }",
            "",
            "    int[] readArray(int n) {",
            "        int[] a = new int[n];",
            "        for (int i = 0; i < n; i++)",
            "            a[i] = nextInt();",
            "        return a;",
            "    }",
            "",
            "    long nextLong() {",
            "        return Long.parseLong(next());",
            "    }",
            "}"
        ],
        "description": "FastScanner class for efficient input reading in competitive programming"
    
    },
	 "Competitive Programming Utilities": {
        "prefix": "cputils",
        "body": [
            "static Random random = new Random();",
            "static final long mod = 1000000007;",
            "",
            "static void ruffleSort(int[] a) {",
            "    int n = a.length; // shuffle, then sort",
            "    for (int i = 0; i < n; i++) {",
            "        int oi = random.nextInt(n), temp = a[oi];",
            "        a[oi] = a[i];",
            "        a[i] = temp;",
            "    }",
            "    Arrays.sort(a);",
            "}",
            "",
            "static long add(long a, long b) {",
            "    return (a + b) % mod;",
            "}",
            "",
            "static long sub(long a, long b) {",
            "    return ((a - b) % mod + mod) % mod;",
            "}",
            "",
            "static long mul(long a, long b) {",
            "    return (a * b) % mod;",
            "}",
            "",
            "static long exp(long base, long exp) {",
            "    if (exp == 0)",
            "        return 1;",
            "    long half = exp(base, exp / 2);",
            "    if (exp % 2 == 0)",
            "        return mul(half, half);",
            "    return mul(half, mul(half, base));",
            "}",
            "",
            "static long[] factorials = new long[2_000_001];",
            "static long[] invFactorials = new long[2_000_001];",
            "",
            "static void precompFacts() {",
            "    factorials[0] = invFactorials[0] = 1;",
            "    for (int i = 1; i < factorials.length; i++)",
            "        factorials[i] = mul(factorials[i - 1], i);",
            "    invFactorials[factorials.length - 1] = exp(factorials[factorials.length - 1], mod - 2);",
            "    for (int i = invFactorials.length - 2; i >= 0; i--)",
            "        invFactorials[i] = mul(invFactorials[i + 1], i + 1);",
            "}",
            "",
            "static long nCk(int n, int k) {",
            "    return mul(factorials[n], mul(invFactorials[k], invFactorials[n - k]));",
            "}",
            "",
            "static void sort(int[] a) {",
            "    ArrayList<Integer> l = new ArrayList<>();",
            "    for (int i : a)",
            "        l.add(i);",
            "    Collections.sort(l);",
            "    for (int i = 0; i < a.length; i++)",
            "        a[i] = l.get(i);",
            "}"
        ],
        "description": "Utility methods for competitive programming: shuffle and sort, modular arithmetic, binomial coefficients, and custom array sort"
    },
    "File input/output": {
        "prefix": "open_file",
        "body": [
            "static void openFile(String filename) throws IOException {",
            "    System.setIn(new FileInputStream(filename + \".in\"));",
            "    System.setOut(new PrintStream(filename + \".out\"));",
            "}"
        ],
        "description": "File input/output"
    },
    "lambda function": {
        "prefix": "lambda",
        "body": [
            "java.util.function.Function<Integer, Boolean> ok = x -> {",
            "    return true; // Replace with your logic",
            "};"
        ],
        "description": "lambda function"
    },
    "Complex": {
        "prefix": "complex",
        "body": [
            "static class Complex {",
            "    double x, y;",
            "",
            "    Complex(double x, double y) {",
            "        this.x = x;",
            "        this.y = y;",
            "    }",
            "",
            "    public String toString() {",
            "        return \"(\" + x + \", \" + y + \")\";",
            "    }",
            "}"
        ],
        "description": "Complex"
    },
    "int128": {
        "prefix": "int128",
        "body": [
            "static BigInteger readBigInt() {",
            "    Scanner sc = new Scanner(System.in);",
            "    return sc.nextBigInteger();",
            "}",
            "",
            "static void printBigInt(BigInteger x) {",
            "    System.out.print(x);",
            "}"
        ],
        "description": "int128"
    },
    "Disjoint Set Union": {
        "prefix": "dsu",
        "body": [
            "static class DSU {",
            "    int[] parent, size;",
            "",
            "    DSU(int n) {",
            "        parent = new int[n];",
            "        size = new int[n];",
            "        for (int i = 0; i < n; i++) {",
            "            parent[i] = i;",
            "            size[i] = 1;",
            "        }",
            "    }",
            "",
            "    int find(int u) {",
            "        if (u != parent[u]) {",
            "            parent[u] = find(parent[u]);",
            "        }",
            "        return parent[u];",
            "    }",
            "",
            "    boolean same(int u, int v) {",
            "        return find(u) == find(v);",
            "    }",
            "",
            "    boolean merge(int u, int v) {",
            "        u = find(u);",
            "        v = find(v);",
            "        if (u == v) return false;",
            "        if (size[u] > size[v]) {",
            "            int temp = u; u = v; v = temp;",
            "        }",
            "        size[v] += size[u];",
            "        parent[u] = v;",
            "        return true;",
            "    }",
            "}"
        ],
        "description": "Disjoint Set Union"
    },
    "dsu (with rollback)": {
        "prefix": "dsu_persistent",
        "body": [
            "static class DSU {",
            "    int num;",
            "    int[] parent, size;",
            "    Stack<Integer> stack;",
            "",
            "    DSU(int n) {",
            "        num = n;",
            "        parent = new int[n];",
            "        size = new int[n];",
            "        stack = new Stack<>();",
            "        for (int i = 0; i < n; i++) {",
            "            parent[i] = i;",
            "            size[i] = 1;",
            "        }",
            "    }",
            "",
            "    int find(int u) {",
            "        if (u != parent[u]) {",
            "            return find(parent[u]);",
            "        }",
            "        return u;",
            "    }",
            "",
            "    boolean same(int u, int v) {",
            "        return find(u) == find(v);",
            "    }",
            "",
            "    boolean merge(int u, int v) {",
            "        u = find(u);",
            "        v = find(v);",
            "        if (u == v) return false;",
            "        if (size[u] > size[v]) {",
            "            int temp = u; u = v; v = temp;",
            "        }",
            "        num--;",
            "        size[v] += size[u];",
            "        parent[u] = v;",
            "        stack.push(u);",
            "        return true;",
            "    }",
            "",
            "    void rollback(int t) {",
            "        while (stack.size() > t) {",
            "            int u = stack.pop();",
            "            num++;",
            "            size[parent[u]] -= size[u];",
            "            parent[u] = u;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Persistent DSU (with rollback)"
    },
    "Persistent Queue": {
        "prefix": "queue_persistent",
        "body": [
            "static class PersistentQueue {",
            "    static final int MAX_L = 20;",
            "    int ver;",
            "    List<Integer> backId, sz, data;",
            "    List<List<Integer>> par;",
            "",
            "    PersistentQueue() {",
            "        ver = 0;",
            "        data = new ArrayList<>(List.of(0));",
            "        par = new ArrayList<>();",
            "        par.add(new ArrayList<>(Collections.nCopies(MAX_L, 0)));",
            "        backId = new ArrayList<>(List.of(0));",
            "        sz = new ArrayList<>(List.of(0));",
            "    }",
            "",
            "    void push(int t, int x) {",
            "        ver++;",
            "        int u = data.size();",
            "        data.add(x);",
            "        List<Integer> newPar = new ArrayList<>(Collections.nCopies(MAX_L, backId.get(t)));",
            "        par.add(newPar);",
            "        backId.add(u);",
            "        sz.add(sz.get(t) + 1);",
            "        for (int i = 1; i < MAX_L; i++) {",
            "            newPar.set(i, par.get(newPar.get(i - 1)).get(i - 1));",
            "        }",
            "    }",
            "",
            "    int pop(int t) {",
            "        ver++;",
            "        int u = backId.get(t), len = sz.get(t) - 1;",
            "        backId.add(u);",
            "        sz.add(len);",
            "        for (int i = 0; i < MAX_L; i++) {",
            "            if ((len & (1 << i)) != 0) {",
            "                u = par.get(u).get(i);",
            "            }",
            "        }",
            "        return data.get(u);",
            "    }",
            "}"
        ],
        "description": "Persistent Queue"
    },
    "Trie": {
        "prefix": "trie",
        "body": [
            "static class Trie {",
            "    static final int MAX_S = 2005;",
            "    static final int MAX_C = 30;",
            "",
            "    int[][] tr = new int[MAX_S][MAX_C];",
            "    int[] cnt = new int[MAX_S];",
            "    int num = 0;",
            "",
            "    void insert(String s) {",
            "        int u = 0;",
            "        for (char c : s.toCharArray()) {",
            "            if (tr[u][c - 'A'] == 0) {",
            "                tr[u][c - 'A'] = ++num;",
            "            }",
            "            u = tr[u][c - 'A'];",
            "        }",
            "        cnt[u]++;",
            "    }",
            "",
            "    boolean search(String s) {",
            "        int u = 0;",
            "        for (char c : s.toCharArray()) {",
            "            if (tr[u][c - 'A'] == 0) return false;",
            "            u = tr[u][c - 'A'];",
            "        }",
            "        return cnt[u] > 0;",
            "    }",
            "}"
        ],
        "description": "Trie"
    },
    "Sparse Table": {
        "prefix": "sparse_table",
        "body": [
            "static class SparseTable {",
            "    int[][] dp;",
            "",
            "    SparseTable(int[] arr) {",
            "        int n = arr.length, k = (int) (Math.log(n) / Math.log(2)) + 1;",
            "        dp = new int[k][n];",
            "        for (int i = 0; i < n; i++) dp[0][i] = arr[i];",
            "        for (int j = 1; j < k; j++) {",
            "            for (int i = 0; i + (1 << j) <= n; i++) {",
            "                dp[j][i] = Math.min(dp[j - 1][i], dp[j - 1][i + (1 << (j - 1))]);",
            "            }",
            "        }",
            "    }",
            "",
            "    int query(int l, int r) {",
            "        int k = (int) (Math.log(r - l + 1) / Math.log(2));",
            "        return Math.min(dp[k][l], dp[k][r - (1 << k) + 1]);",
            "    }",
            "}"
        ],
        "description": "Sparse Table"
    },
    "Segment Tree (range sum, range set)": {
        "prefix": "segtree",
        "body": [
            "static class SegTree {",
            "    static class TData {",
            "        long sum;",
            "        long setval;",
            "",
            "        TData() {",
            "            sum = 0;",
            "            setval = Long.MAX_VALUE;",
            "        }",
            "",
            "        TData(long val) {",
            "            sum = val;",
            "            setval = Long.MAX_VALUE;",
            "        }",
            "",
            "        TData(TData l, TData r) {",
            "            sum = l.sum + r.sum;",
            "            setval = Long.MAX_VALUE;",
            "        }",
            "    }",
            "",
            "    int n;",
            "    TData[] st;",
            "",
            "    SegTree(int n) {",
            "        this.n = n;",
            "        st = new TData[4 * n];",
            "        for (int i = 0; i < 4 * n; i++) st[i] = new TData();",
            "    }",
            "",
            "    SegTree(int[] arr) {",
            "        this(arr.length);",
            "        build(arr, 1, 0, n - 1);",
            "    }",
            "",
            "    void apply(int node, int start, int end, long val) {",
            "        if (val == Long.MAX_VALUE) return;",
            "        st[node].sum = val * (end - start + 1);",
            "        st[node].setval = val;",
            "    }",
            "",
            "    void pullUp(int node) {",
            "        st[node].sum = st[2 * node].sum + st[2 * node + 1].sum;",
            "    }",
            "",
            "    void pushDown(int node, int start, int end) {",
            "        if (start == end) return;",
            "        int mid = (start + end) / 2;",
            "        apply(2 * node, start, mid, st[node].setval);",
            "        apply(2 * node + 1, mid + 1, end, st[node].setval);",
            "        st[node].setval = Long.MAX_VALUE;",
            "    }",
            "",
            "    void build(int[] arr, int node, int start, int end) {",
            "        if (start == end) {",
            "            st[node] = new TData(arr[start]);",
            "            return;",
            "        }",
            "        int mid = (start + end) / 2;",
            "        build(arr, 2 * node, start, mid);",
            "        build(arr, 2 * node + 1, mid + 1, end);",
            "        pullUp(node);",
            "    }",
            "",
            "    void update(int node, int start, int end, int idx, long val) {",
            "        if (start == end) {",
            "            apply(node, start, end, val);",
            "            return;",
            "        }",
            "        pushDown(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        if (idx <= mid) update(2 * node, start, mid, idx, val);",
            "        else update(2 * node + 1, mid + 1, end, idx, val);",
            "        pullUp(node);",
            "    }",
            "",
            "    void update(int node, int start, int end, int l, int r, long val) {",
            "        if (r < start || end < l) return;",
            "        if (l <= start && end <= r) {",
            "            apply(node, start, end, val);",
            "            return;",
            "        }",
            "        pushDown(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        update(2 * node, start, mid, l, r, val);",
            "        update(2 * node + 1, mid + 1, end, l, r, val);",
            "        pullUp(node);",
            "    }",
            "",
            "    TData query(int node, int start, int end, int l, int r) {",
            "        if (r < start || end < l) return new TData();",
            "        if (l <= start && end <= r) return st[node];",
            "        pushDown(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        return new TData(query(2 * node, start, mid, l, r), query(2 * node + 1, mid + 1, end, l, r));",
            "    }",
            "",
            "    void update(int idx, long val) {",
            "        update(1, 0, n - 1, idx, val);",
            "    }",
            "",
            "    void update(int l, int r, long val) {",
            "        update(1, 0, n - 1, l, r, val);",
            "    }",
            "",
            "    TData query(int l, int r) {",
            "        return query(1, 0, n - 1, l, r);",
            "    }",
            "}"
        ],
        "description": "Segment Tree (range sum, range set)"
    },
    "Dynamic Segment Tree (range sum, range set)": {
        "prefix": "segtree_dynamic",
        "body": [
            "static class SegTree {",
            "    static class TData {",
            "        TData ln, rn;",
            "        int start, end;",
            "        long sum, setval;",
            "",
            "        TData() {",
            "            start = 0;",
            "            end = 0;",
            "            sum = 0;",
            "            setval = Long.MAX_VALUE;",
            "        }",
            "",
            "        TData(int start, int end, long val) {",
            "            this.start = start;",
            "            this.end = end;",
            "            this.sum = val;",
            "            this.setval = Long.MAX_VALUE;",
            "        }",
            "",
            "        TData(TData l, TData r) {",
            "            this.start = l.start;",
            "            this.end = r.end;",
            "            this.sum = l.sum + r.sum;",
            "            this.setval = Long.MAX_VALUE;",
            "        }",
            "",
            "        void init() {",
            "            if (ln == null || rn == null) {",
            "                int mid = (start + end) / 2;",
            "                ln = new TData(start, mid, 0);",
            "                rn = new TData(mid + 1, end, 0);",
            "            }",
            "        }",
            "    }",
            "",
            "    int n;",
            "    TData st;",
            "",
            "    SegTree(int n) {",
            "        this.n = n;",
            "        st = new TData(0, n - 1, 0);",
            "    }",
            "",
            "    void apply(TData node, long val) {",
            "        if (val == Long.MAX_VALUE) return;",
            "        node.sum = val * (node.end - node.start + 1);",
            "        node.setval = val;",
            "    }",
            "",
            "    void pullUp(TData node) {",
            "        node.sum = node.ln.sum + node.rn.sum;",
            "    }",
            "",
            "    void pushDown(TData node) {",
            "        if (node.start == node.end) return;",
            "        node.init();",
            "        apply(node.ln, node.setval);",
            "        apply(node.rn, node.setval);",
            "        node.setval = Long.MAX_VALUE;",
            "    }",
            "",
            "    void update(TData node, int idx, long val) {",
            "        if (node.start == node.end) {",
            "            apply(node, val);",
            "            return;",
            "        }",
            "        pushDown(node);",
            "        node.init();",
            "        int mid = (node.start + node.end) / 2;",
            "        if (idx <= mid) update(node.ln, idx, val);",
            "        else update(node.rn, idx, val);",
            "        pullUp(node);",
            "    }",
            "",
            "    void update(TData node, int l, int r, long val) {",
            "        if (r < node.start || node.end < l) return;",
            "        if (l <= node.start && node.end <= r) {",
            "            apply(node, val);",
            "            return;",
            "        }",
            "        pushDown(node);",
            "        node.init();",
            "        update(node.ln, l, r, val);",
            "        update(node.rn, l, r, val);",
            "        pullUp(node);",
            "    }",
            "",
            "    TData query(TData node, int l, int r) {",
            "        if (r < node.start || node.end < l) return new TData();",
            "        if (l <= node.start && node.end <= r) return node;",
            "        pushDown(node);",
            "        node.init();",
            "        return new TData(query(node.ln, l, r), query(node.rn, l, r));",
            "    }",
            "",
            "    void update(int idx, long val) {",
            "        update(st, idx, val);",
            "    }",
            "",
            "    void update(int l, int r, long val) {",
            "        update(st, l, r, val);",
            "    }",
            "",
            "    TData query(int l, int r) {",
            "        return query(st, l, r);",
            "    }",
            "}"
        ],
        "description": "Dynamic Segment Tree (range sum, range set)"
    },
    "Persistent Segment Tree (range sum, range set, copy)": {
        "prefix": "segtree_persistent",
        "body": [
            "static class SegTree {",
            "    static class TData {",
            "        TData ln, rn;",
            "        long sum, setval;",
            "",
            "        TData() {",
            "            sum = 0;",
            "            setval = Long.MAX_VALUE;",
            "        }",
            "",
            "        TData(long val) {",
            "            sum = val;",
            "            setval = Long.MAX_VALUE;",
            "        }",
            "",
            "        TData(TData ln, TData rn, long val) {",
            "            this.ln = ln;",
            "            this.rn = rn;",
            "            this.sum = val;",
            "            this.setval = Long.MAX_VALUE;",
            "        }",
            "",
            "        TData(TData l, TData r) {",
            "            sum = l.sum + r.sum;",
            "            setval = Long.MAX_VALUE;",
            "        }",
            "",
            "        void init() {",
            "            if (ln == null || rn == null) {",
            "                ln = new TData();",
            "                rn = new TData();",
            "            }",
            "        }",
            "    }",
            "",
            "    int n, ver;",
            "    TData[] st;",
            "",
            "    SegTree(int n, int q) {",
            "        this.n = n;",
            "        this.ver = 0;",
            "        st = new TData[q];",
            "        st[0] = new TData();",
            "    }",
            "",
            "    SegTree(int[] arr, int q) {",
            "        this(arr.length, q);",
            "        build(arr, st[0], 0, n - 1);",
            "    }",
            "",
            "    void apply(TData node, int start, int end, long val) {",
            "        if (val == Long.MAX_VALUE) return;",
            "        node.sum = val * (end - start + 1);",
            "        node.setval = val;",
            "    }",
            "",
            "    void pullUp(TData node) {",
            "        node.sum = node.ln.sum + node.rn.sum;",
            "    }",
            "",
            "    void pushDown(TData node, int start, int end) {",
            "        if (start == end || node.setval == Long.MAX_VALUE) return;",
            "        node.init();",
            "        int mid = (start + end) / 2;",
            "        apply(node.ln, start, mid, node.setval);",
            "        apply(node.rn, mid + 1, end, node.setval);",
            "        node.setval = Long.MAX_VALUE;",
            "    }",
            "",
            "    void build(int[] arr, TData node, int start, int end) {",
            "        if (start == end) {",
            "            node.sum = arr[start];",
            "            return;",
            "        }",
            "        node.init();",
            "        int mid = (start + end) / 2;",
            "        build(arr, node.ln, start, mid);",
            "        build(arr, node.rn, mid + 1, end);",
            "        pullUp(node);",
            "    }",
            "",
            "    void update(TData node, int start, int end, int idx, long val) {",
            "        if (start == end) {",
            "            apply(node, start, end, val);",
            "            return;",
            "        }",
            "        pushDown(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        if (idx <= mid) {",
            "            node.ln = new TData(node.ln.ln, node.ln.rn, node.ln.sum);",
            "            update(node.ln, start, mid, idx, val);",
            "        } else {",
            "            node.rn = new TData(node.rn.ln, node.rn.rn, node.rn.sum);",
            "            update(node.rn, mid + 1, end, idx, val);",
            "        }",
            "        pullUp(node);",
            "    }",
            "",
            "    void update(TData node, int start, int end, int l, int r, long val) {",
            "        if (r < start || end < l) return;",
            "        if (l <= start && end <= r) {",
            "            apply(node, start, end, val);",
            "            return;",
            "        }",
            "        pushDown(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        node.ln = new TData(node.ln.ln, node.ln.rn, node.ln.sum);",
            "        node.rn = new TData(node.rn.ln, node.rn.rn, node.rn.sum);",
            "        update(node.ln, start, mid, l, r, val);",
            "        update(node.rn, mid + 1, end, l, r, val);",
            "        pullUp(node);",
            "    }",
            "",
            "    TData query(TData node, int start, int end, int l, int r) {",
            "        if (r < start || end < l) return new TData();",
            "        if (l <= start && end <= r) return node;",
            "        pushDown(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        return new TData(query(node.ln, start, mid, l, r), query(node.rn, mid + 1, end, l, r));",
            "    }",
            "",
            "    void update(int k, int idx, long val) {",
            "        update(st[k], 0, n - 1, idx, val);",
            "    }",
            "",
            "    void update(int k, int l, int r, long val) {",
            "        update(st[k], 0, n - 1, l, r, val);",
            "    }",
            "",
            "    TData query(int k, int l, int r) {",
            "        return query(st[k], 0, n - 1, l, r);",
            "    }",
            "",
            "    void copy(int k) {",
            "        st[++ver] = new TData(st[k].ln, st[k].rn, st[k].sum);",
            "    }",
            "}"
        ],
        "description": "Persistent Segment Tree (range sum, range set, copy)"
    },
    "Segment Tree Beats": {
        "prefix": "segtreebeats",
        "body": [
            "static class SegTree {",
            "    static class TData {",
            "        long sum, addval, mx, mx2, mxCnt, mn, mn2, mnCnt;",
            "",
            "        TData() {",
            "            sum = 0;",
            "            addval = 0;",
            "            mx = Long.MIN_VALUE;",
            "            mx2 = Long.MIN_VALUE;",
            "            mxCnt = 0;",
            "            mn = Long.MAX_VALUE;",
            "            mn2 = Long.MAX_VALUE;",
            "            mnCnt = 0;",
            "        }",
            "",
            "        TData(long val) {",
            "            sum = val;",
            "            addval = 0;",
            "            mx = val;",
            "            mx2 = Long.MIN_VALUE;",
            "            mxCnt = 1;",
            "            mn = val;",
            "            mn2 = Long.MAX_VALUE;",
            "            mnCnt = 1;",
            "        }",
            "",
            "        TData(TData l, TData r) {",
            "            sum = l.sum + r.sum;",
            "            mx = Math.max(l.mx, r.mx);",
            "            mx2 = Math.max(l.mx2, r.mx2);",
            "            mxCnt = 0;",
            "            if (l.mx == mx) mxCnt += l.mxCnt;",
            "            else mx2 = Math.max(mx2, l.mx);",
            "            if (r.mx == mx) mxCnt += r.mxCnt;",
            "            else mx2 = Math.max(mx2, r.mx);",
            "            mn = Math.min(l.mn, r.mn);",
            "            mn2 = Math.min(l.mn2, r.mn2);",
            "            mnCnt = 0;",
            "            if (l.mn == mn) mnCnt += l.mnCnt;",
            "            else mn2 = Math.min(mn2, l.mn);",
            "            if (r.mn == mn) mnCnt += r.mnCnt;",
            "            else mn2 = Math.min(mn2, r.mn);",
            "        }",
            "    }",
            "",
            "    int n;",
            "    TData[] st;",
            "",
            "    SegTree(int n) {",
            "        this.n = n;",
            "        st = new TData[4 * n];",
            "        for (int i = 0; i < 4 * n; i++) st[i] = new TData();",
            "    }",
            "",
            "    SegTree(long[] arr) {",
            "        this(arr.length);",
            "        build(arr, 1, 0, n - 1);",
            "    }",
            "",
            "    void applyAdd(int node, int start, int end, long val) {",
            "        if (val == 0) return;",
            "        st[node].sum += val * (end - start + 1);",
            "        st[node].addval += val;",
            "        st[node].mx += val;",
            "        if (st[node].mx2 != Long.MIN_VALUE) st[node].mx2 += val;",
            "        st[node].mn += val;",
            "        if (st[node].mn2 != Long.MAX_VALUE) st[node].mn2 += val;",
            "    }",
            "",
            "    void applyMin(int node, int start, int end, long val) {",
            "        if (val >= st[node].mx) return;",
            "        st[node].sum -= (st[node].mx - val) * st[node].mxCnt;",
            "        st[node].mx = val;",
            "        if (val < st[node].mn) st[node].mn = val;",
            "        else if (val < st[node].mn2) st[node].mn2 = val;",
            "    }",
            "",
            "    void applyMax(int node, int start, int end, long val) {",
            "        if (val <= st[node].mn) return;",
            "        st[node].sum += (val - st[node].mn) * st[node].mnCnt;",
            "        st[node].mn = val;",
            "        if (val > st[node].mx) st[node].mx = val;",
            "        else if (val > st[node].mx2) st[node].mx2 = val;",
            "    }",
            "",
            "    void pullUp(int node) {",
            "        st[node].sum = st[2 * node].sum + st[2 * node + 1].sum;",
            "        st[node].mx = Math.max(st[2 * node].mx, st[2 * node + 1].mx);",
            "        st[node].mx2 = Math.max(st[2 * node].mx2, st[2 * node + 1].mx2);",
            "        st[node].mxCnt = 0;",
            "        if (st[2 * node].mx == st[node].mx) st[node].mxCnt += st[2 * node].mxCnt;",
            "        else st[node].mx2 = Math.max(st[node].mx2, st[2 * node].mx);",
            "        if (st[2 * node + 1].mx == st[node].mx) st[node].mxCnt += st[2 * node + 1].mxCnt;",
            "        else st[node].mx2 = Math.max(st[node].mx2, st[2 * node + 1].mx);",
            "        st[node].mn = Math.min(st[2 * node].mn, st[2 * node + 1].mn);",
            "        st[node].mn2 = Math.min(st[2 * node].mn2, st[2 * node + 1].mn2);",
            "        st[node].mnCnt = 0;",
            "        if (st[2 * node].mn == st[node].mn) st[node].mnCnt += st[2 * node].mnCnt;",
            "        else st[node].mn2 = Math.min(st[node].mn2, st[2 * node].mn);",
            "        if (st[2 * node + 1].mn == st[node].mn) st[node].mnCnt += st[2 * node + 1].mnCnt;",
            "        else st[node].mn2 = Math.min(st[node].mn2, st[2 * node + 1].mn);",
            "    }",
            "",
            "    void pushDown(int node, int start, int end) {",
            "        if (start == end) return;",
            "        int mid = (start + end) / 2;",
            "        applyAdd(2 * node, start, mid, st[node].addval);",
            "        applyAdd(2 * node + 1, mid + 1, end, st[node].addval);",
            "        st[node].addval = 0;",
            "        applyMin(2 * node, start, mid, st[node].mx);",
            "        applyMin(2 * node + 1, mid + 1, end, st[node].mx);",
            "        applyMax(2 * node, start, mid, st[node].mn);",
            "        applyMax(2 * node + 1, mid + 1, end, st[node].mn);",
            "    }",
            "",
            "    void build(long[] arr, int node, int start, int end) {",
            "        if (start == end) {",
            "            st[node] = new TData(arr[start]);",
            "            return;",
            "        }",
            "        int mid = (start + end) / 2;",
            "        build(arr, 2 * node, start, mid);",
            "        build(arr, 2 * node + 1, mid + 1, end);",
            "        pullUp(node);",
            "    }",
            "",
            "    void updateAdd(int node, int start, int end, int l, int r, long val) {",
            "        pushDown(node, start, end);",
            "        if (r < start || end < l) return;",
            "        if (l <= start && end <= r) {",
            "            applyAdd(node, start, end, val);",
            "            return;",
            "        }",
            "        int mid = (start + end) / 2;",
            "        updateAdd(2 * node, start, mid, l, r, val);",
            "        updateAdd(2 * node + 1, mid + 1, end, l, r, val);",
            "        pullUp(node);",
            "    }",
            "",
            "    void updateMin(int node, int start, int end, int l, int r, long val) {",
            "        if (r < start || end < l || st[node].mx <= val) return;",
            "        if (l <= start && end <= r && st[node].mx2 < val) {",
            "            applyMin(node, start, end, val);",
            "            return;",
            "        }",
            "        pushDown(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        updateMin(2 * node, start, mid, l, r, val);",
            "        updateMin(2 * node + 1, mid + 1, end, l, r, val);",
            "        pullUp(node);",
            "    }",
            "",
            "    void updateMax(int node, int start, int end, int l, int r, long val) {",
            "        if (r < start || end < l || st[node].mn >= val) return;",
            "        if (l <= start && end <= r && st[node].mn2 > val) {",
            "            applyMax(node, start, end, val);",
            "            return;",
            "        }",
            "        pushDown(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        updateMax(2 * node, start, mid, l, r, val);",
            "        updateMax(2 * node + 1, mid + 1, end, l, r, val);",
            "        pullUp(node);",
            "    }",
            "",
            "    TData query(int node, int start, int end, int l, int r) {",
            "        if (r < start || end < l) return new TData();",
            "        if (l <= start && end <= r) return st[node];",
            "        pushDown(node, start, end);",
            "        int mid = (start + end) / 2;",
            "        return new TData(query(2 * node, start, mid, l, r), query(2 * node + 1, mid + 1, end, l, r));",
            "    }",
            "",
            "    void updateAdd(int l, int r, long val) {",
            "        updateAdd(1, 0, n - 1, l, r, val);",
            "    }",
            "",
            "    void updateMin(int l, int r, long val) {",
            "        updateMin(1, 0, n - 1, l, r, val);",
            "    }",
            "",
            "    void updateMax(int l, int r, long val) {",
            "        updateMax(1, 0, n - 1, l, r, val);",
            "    }",
            "",
            "    TData query(int l, int r) {",
            "        return query(1, 0, n - 1, l, r);",
            "    }",
            "}"
        ],
        "description": "Segment Tree Beats"
    },
    "Fenwick Tree (PURQ && RUPQ && OST)": {
        "prefix": "fwtree",
        "body": [
            "static class FenwickTree {",
            "    static final int MAX_L = 20;",
            "    int n;",
            "    long[] ft;",
            "",
            "    FenwickTree(int n) {",
            "        this.n = n;",
            "        ft = new long[n + 1];",
            "    }",
            "",
            "    void update(int x, long v) {",
            "        for (; x <= n; x += x & -x) ft[x] += v;",
            "    }",
            "",
            "    void update(int l, int r, long v) {",
            "        update(l, v);",
            "        update(r + 1, -v);",
            "    }",
            "",
            "    long sum(int x) {",
            "        long res = 0;",
            "        for (; x > 0; x -= x & -x) res += ft[x];",
            "        return res;",
            "    }",
            "",
            "    long query(int l, int r) {",
            "        return sum(r) - sum(l - 1);",
            "    }",
            "",
            "    int findByOrder(int k) {",
            "        int sum = 0, pos = 0;",
            "        for (int i = MAX_L; i >= 0; i--) {",
            "            if (pos + (1 << i) < n && sum + ft[pos + (1 << i)] < k) {",
            "                sum += ft[pos + (1 << i)];",
            "                pos += (1 << i);",
            "            }",
            "        }",
            "        return pos + 1;",
            "    }",
            "",
            "    int orderOfKey(int k) {",
            "        return (int) sum(k);",
            "    }",
            "}"
        ],
        "description": "Fenwick Tree (PURQ && RUPQ && OST)"
    },
    "Fenwick Tree (RURQ)": {
        "prefix": "fwtree_RURQ",
        "body": [
            "static class FenwickTree {",
            "    int n;",
            "    long[] ft1, ft2;",
            "",
            "    FenwickTree(int n) {",
            "        this.n = n;",
            "        ft1 = new long[n + 1];",
            "        ft2 = new long[n + 1];",
            "    }",
            "",
            "    void update(long[] ft, int x, long v) {",
            "        for (; x <= n; x += x & -x) ft[x] += v;",
            "    }",
            "",
            "    void update(int l, int r, long v) {",
            "        update(ft1, l, v);",
            "        update(ft1, r + 1, -v);",
            "        update(ft2, l, v * (l - 1));",
            "        update(ft2, r + 1, -v * r);",
            "    }",
            "",
            "    long sum(long[] ft, int x) {",
            "        long res = 0;",
            "        for (; x > 0; x -= x & -x) res += ft[x];",
            "        return res;",
            "    }",
            "",
            "    long sum(int x) {",
            "        return sum(ft1, x) * x - sum(ft2, x);",
            "    }",
            "",
            "    long query(int l, int r) {",
            "        return sum(r) - sum(l - 1);",
            "    }",
            "}"
        ],
        "description": "Fenwick Tree (RURQ)"
    },
    "Fenwick Tree (2D)": {
        "prefix": "fwtree2d",
        "body": [
            "static class FenwickTree2D {",
            "    int n;",
            "    long[][] ft;",
            "",
            "    FenwickTree2D(int n) {",
            "        this.n = n;",
            "        ft = new long[n + 1][n + 1];",
            "    }",
            "",
            "    void update(int x, int y, long v) {",
            "        for (int tx = x; tx <= n; tx += tx & -tx) {",
            "            for (int ty = y; ty <= n; ty += ty & -ty) {",
            "                ft[tx][ty] += v;",
            "            }",
            "        }",
            "    }",
            "",
            "    long sum(int x, int y) {",
            "        long res = 0;",
            "        for (int tx = x; tx > 0; tx -= tx & -tx) {",
            "            for (int ty = y; ty > 0; ty -= ty & -ty) {",
            "                res += ft[tx][ty];",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "",
            "    long query(int x1, int y1, int x2, int y2) {",
            "        return sum(x2, y2) - sum(x1 - 1, y2) - sum(x2, y1 - 1) + sum(x1 - 1, y1 - 1);",
            "    }",
            "}"
        ],
        "description": "Fenwick Tree (2D)"
    },
    "nCk (no MOD)": {
        "prefix": "nCk_ll",
        "body": [
            "static long nCk(int n, int k) {",
            "    if (k < 0 || k > n) return 0;",
            "    k = Math.min(k, n - k);",
            "    long res = 1, tmp = 1;",
            "    while (k > 0) {",
            "        res *= n;",
            "        tmp *= k;",
            "        long d = gcd(res, tmp);",
            "        res /= d;",
            "        tmp /= d;",
            "        n--; k--;",
            "    }",
            "    return res;",
            "}",
            "",
            "static long gcd(long a, long b) {",
            "    return b == 0 ? a : gcd(b, a % b);",
            "}"
        ],
        "description": "nCk (no MOD)"
    },
    "Binomial Coefficients": {
        "prefix": "nCk",
        "body": [
            "static final long MOD = 1000000007;",
            "",
            "static long qexp(long a, long b, long m) {",
            "    long res = 1;",
            "    while (b > 0) {",
            "        if ((b & 1) == 1) res = res * a % m;",
            "        a = a * a % m;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}",
            "",
            "static long[] fact, invf;",
            "",
            "static void precompute(int n) {",
            "    fact = new long[n + 1];",
            "    invf = new long[n + 1];",
            "    fact[0] = 1;",
            "    for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i % MOD;",
            "    invf[n] = qexp(fact[n], MOD - 2, MOD);",
            "    for (int i = n - 1; i > 0; i--) invf[i] = invf[i + 1] * (i + 1) % MOD;",
            "    invf[0] = 1;",
            "}",
            "",
            "static long nCk(int n, int k) {",
            "    if (k < 0 || k > n) return 0;",
            "    return fact[n] * invf[k] % MOD * invf[n - k] % MOD;",
            "}"
        ],
        "description": "Binomial Coefficients"
    },
    "Matrix": {
        "prefix": "matrix",
        "body": [
            "static class Matrix<T> {",
            "    T[][] m;",
            "    int r, c;",
            "",
            "    Matrix() {",
            "        r = 0;",
            "        c = 0;",
            "    }",
            "",
            "    Matrix(int r, int c, T x) {",
            "        this.r = r;",
            "        this.c = c;",
            "        m = (T[][]) new Object[r][c];",
            "        for (int i = 0; i < r; i++) Arrays.fill(m[i], x);",
            "    }",
            "",
            "    Matrix(int n) {",
            "        this(n, n, 0);",
            "        for (int i = 0; i < n; i++) m[i][i] = (T) Integer.valueOf(1);",
            "    }",
            "",
            "    Matrix<T> add(Matrix<T> b) {",
            "        Matrix<T> a = this;",
            "        assert a.r == b.r && a.c == b.c;",
            "        Matrix<T> o = new Matrix<>(a.r, a.c, 0);",
            "        for (int i = 0; i < a.r; i++) {",
            "            for (int j = 0; j < a.c; j++) {",
            "                o.m[i][j] = (T) (Integer) (((Integer) a.m[i][j] + (Integer) b.m[i][j]));",
            "            }",
            "        }",
            "        return o;",
            "    }",
            "",
            "    Matrix<T> subtract(Matrix<T> b) {",
            "        Matrix<T> a = this;",
            "        assert a.r == b.r && a.c == b.c;",
            "        Matrix<T> o = new Matrix<>(a.r, a.c, 0);",
            "        for (int i = 0; i < a.r; i++) {",
            "            for (int j = 0; j < a.c; j++) {",
            "                o.m[i][j] = (T) (Integer) (((Integer) a.m[i][j] - (Integer) b.m[i][j]));",
            "            }",
            "        }",
            "        return o;",
            "    }",
            "",
            "    Matrix<T> multiply(Matrix<T> b) {",
            "        Matrix<T> a = this;",
            "        assert a.c == b.r;",
            "        Matrix<T> o = new Matrix<>(a.r, b.c, 0);",
            "        for (int i = 0; i < a.r; i++) {",
            "            for (int j = 0; j < b.c; j++) {",
            "                for (int k = 0; k < a.c; k++) {",
            "                    o.m[i][j] = (T) (Integer) (((Integer) o.m[i][j] + ((Integer) a.m[i][k] * (Integer) b.m[k][j])));",
            "                }",
            "            }",
            "        }",
            "        return o;",
            "    }",
            "",
            "    Matrix<T> power(long b) {",
            "        Matrix<T> a = this;",
            "        assert a.r == a.c;",
            "        Matrix<T> o = new Matrix<>(a.r);",
            "        while (b > 0) {",
            "            if ((b & 1) == 1) o = o.multiply(a);",
            "            a = a.multiply(a);",
            "            b >>= 1;",
            "        }",
            "        return o;",
            "    }",
            "",
            "    void print() {",
            "        for (int i = 0; i < r; i++) {",
            "            for (int j = 0; j < c; j++) {",
            "                System.out.print(m[i][j] + \" \");",
            "            }",
            "            System.out.println();",
            "        }",
            "    }",
            "}"
        ],
        "description": "Matrix"
    },
    "Quick Exponentiation": {
        "prefix": "qexp",
        "body": [
            "static long qexp(long a, long b, long m) {",
            "    long res = 1;",
            "    while (b > 0) {",
            "        if ((b & 1) == 1) res = res * a % m;",
            "        a = a * a % m;",
            "        b >>= 1;",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Quick Exponentiation"
    },
    "Max Flow Algorithm": {
        "prefix": "max_flow",
        "body": [
            "static class MaxFlowGraph {",
            "    static class Edge {",
            "        int u, v, cap, flow;",
            "",
            "        Edge(int u, int v, int cap, int flow) {",
            "            this.u = u;",
            "            this.v = v;",
            "            this.cap = cap;",
            "            this.flow = flow;",
            "        }",
            "    }",
            "",
            "    int n;",
            "    List<Edge> el;",
            "    List<List<Integer>> adj;",
            "    int[] dist, par, vis;",
            "",
            "    MaxFlowGraph(int n) {",
            "        this.n = n;",
            "        el = new ArrayList<>();",
            "        adj = new ArrayList<>();",
            "        for (int i = 0; i < n; i++) adj.add(new ArrayList<>());",
            "    }",
            "",
            "    void addEdge(int u, int v, int w) {",
            "        adj.get(u).add(el.size());",
            "        el.add(new Edge(u, v, w, 0));",
            "        adj.get(v).add(el.size());",
            "        el.add(new Edge(v, u, 0, 0));",
            "    }",
            "",
            "    int sendOneFlow(int s, int e) {",
            "        int nf = Integer.MAX_VALUE;",
            "        for (int u = e; u != s; u = el.get(par[u]).u) {",
            "            nf = Math.min(nf, el.get(par[u]).cap - el.get(par[u]).flow);",
            "        }",
            "        for (int u = e; u != s; u = el.get(par[u]).u) {",
            "            el.get(par[u]).flow += nf;",
            "            el.get(par[u] ^ 1).flow -= nf;",
            "        }",
            "        return nf;",
            "    }",
            "",
            "    boolean bfs(int s, int e) {",
            "        dist = new int[n];",
            "        par = new int[n];",
            "        Arrays.fill(dist, Integer.MAX_VALUE);",
            "        Queue<Integer> q = new LinkedList<>();",
            "        q.add(s);",
            "        dist[s] = 0;",
            "        while (!q.isEmpty()) {",
            "            int u = q.poll();",
            "            if (u == e) break;",
            "            for (int idx : adj.get(u)) {",
            "                if (el.get(idx).cap > el.get(idx).flow && dist[el.get(idx).v] > dist[el.get(idx).u] + 1) {",
            "                    dist[el.get(idx).v] = dist[el.get(idx).u] + 1;",
            "                    par[el.get(idx).v] = idx;",
            "                    q.add(el.get(idx).v);",
            "                }",
            "            }",
            "        }",
            "        return dist[e] < Integer.MAX_VALUE;",
            "    }",
            "",
            "    int dfs(int s, int e, int f) {",
            "        if (s == e || f == 0) return f;",
            "        for (int idx : adj.get(s)) {",
            "            if (dist[el.get(idx).v] != dist[s] + 1) continue;",
            "            int nf = dfs(el.get(idx).v, e, Math.min(f, el.get(idx).cap - el.get(idx).flow));",
            "            if (nf != 0) {",
            "                el.get(idx).flow += nf;",
            "                el.get(idx ^ 1).flow -= nf;",
            "                return nf;",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    long edmondsKarp(int s, int e) {",
            "        long mf = 0;",
            "        while (bfs(s, e)) mf += sendOneFlow(s, e);",
            "        return mf;",
            "    }",
            "",
            "    long dinic(int s, int e) {",
            "        long mf = 0;",
            "        while (bfs(s, e)) {",
            "            int nf;",
            "            while ((nf = dfs(s, e, Integer.MAX_VALUE)) != 0) mf += nf;",
            "        }",
            "        return mf;",
            "    }",
            "",
            "    void dfsCut(int u) {",
            "        vis[u] = 1;",
            "        for (int idx : adj.get(u)) {",
            "            Edge edge = el.get(idx);",
            "            if (vis[edge.v] != 0 || edge.flow >= edge.cap) continue;",
            "            dfsCut(edge.v);",
            "        }",
            "    }",
            "",
            "    List<int[]> minCut(int s, int e) {",
            "        long mf = dinic(s, e);",
            "        vis = new int[n];",
            "        dfsCut(s);",
            "        List<int[]> res = new ArrayList<>();",
            "        for (Edge edge : el) {",
            "            if (vis[edge.u] != vis[edge.v] && edge.cap == edge.flow) {",
            "                res.add(new int[]{edge.u, edge.v});",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "}"
        ],
        "description": "Max Flow Algorithm"
    },
    "Basic Sieve": {
        "prefix": "sieve",
        "body": [
            "static List<Integer> primes = new ArrayList<>();",
            "static boolean[] isPrime;",
            "static int[] spf;",
            "",
            "static void sieve(int n) {",
            "    primes.clear();",
            "    isPrime = new boolean[n + 1];",
            "    spf = new int[n + 1];",
            "    Arrays.fill(isPrime, true);",
            "    isPrime[0] = isPrime[1] = false;",
            "    for (long i = 2; i <= n; i++) {",
            "        if (isPrime[(int) i]) {",
            "            primes.add((int) i);",
            "            spf[(int) i] = (int) i;",
            "            for (long j = i * i; j <= n; j += i) {",
            "                isPrime[(int) j] = false;",
            "                spf[(int) j] = (int) i;",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Basic Sieve"
    },
    "Linear Sieve": {
        "prefix": "sieve_advanced",
        "body": [
            "static List<Integer> primes = new ArrayList<>();",
            "static boolean[] isPrime;",
            "static int[] spf, mobius, phi;",
            "",
            "static void sieve(int n) {",
            "    primes.clear();",
            "    isPrime = new boolean[n + 1];",
            "    spf = new int[n + 1];",
            "    mobius = new int[n + 1];",
            "    phi = new int[n + 1];",
            "    Arrays.fill(isPrime, true);",
            "    isPrime[0] = isPrime[1] = false;",
            "    mobius[1] = phi[1] = 1;",
            "    for (long i = 2; i <= n; i++) {",
            "        if (isPrime[(int) i]) {",
            "            primes.add((int) i);",
            "            spf[(int) i] = (int) i;",
            "            mobius[(int) i] = -1;",
            "            phi[(int) i] = (int) i - 1;",
            "        }",
            "        for (int p : primes) {",
            "            if (i * p > n || p > spf[(int) i]) break;",
            "            isPrime[(int) (i * p)] = false;",
            "            spf[(int) (i * p)] = p;",
            "            mobius[(int) (i * p)] = (spf[(int) i] == p) ? 0 : -mobius[(int) i];",
            "            phi[(int) (i * p)] = (spf[(int) i] == p) ? phi[(int) i] * p : phi[(int) i] * phi[p];",
            "        }",
            "    }",
            "}"
        ],
        "description": "Linear Sieve"
    },
    "Modular Arithmetic": {
        "prefix": "mint",
        "body": [
            "static class Modular {",
            "    static final int MOD = 1000000007;",
            "    int v;",
            "",
            "    Modular() {",
            "        v = 0;",
            "    }",
            "",
            "    Modular(long v) {",
            "        if (v >= MOD || v < -MOD) v %= MOD;",
            "        if (v < 0) v += MOD;",
            "        this.v = (int) v;",
            "    }",
            "",
            "    public String toString() {",
            "        return String.valueOf(v);",
            "    }",
            "",
            "    boolean equals(Modular other) {",
            "        return v == other.v;",
            "    }",
            "",
            "    boolean lessThan(Modular other) {",
            "        return v < other.v;",
            "    }",
            "",
            "    Modular add(Modular m) {",
            "        Modular res = new Modular(v + m.v);",
            "        if (res.v >= MOD) res.v -= MOD;",
            "        return res;",
            "    }",
            "",
            "    Modular subtract(Modular m) {",
            "        Modular res = new Modular(v - m.v);",
            "        if (res.v < 0) res.v += MOD;",
            "        return res;",
            "    }",
            "",
            "    Modular multiply(Modular m) {",
            "        return new Modular((long) v * m.v % MOD);",
            "    }",
            "",
            "    Modular divide(Modular m) {",
            "        return multiply(inv(m));",
            "    }",
            "",
            "    Modular negate() {",
            "        return new Modular(-v);",
            "    }",
            "",
            "    Modular pow(long p) {",
            "        Modular res = new Modular(1);",
            "        Modular a = this;",
            "        assert p >= 0;",
            "        while (p > 0) {",
            "            if ((p & 1) == 1) res = res.multiply(a);",
            "            a = a.multiply(a);",
            "            p >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "",
            "    static Modular inv(Modular a) {",
            "        assert a.v != 0;",
            "        return a.pow(MOD - 2);",
            "    }",
            "}"
        ],
        "description": "Modular Arithmetic"
    },
    "Floor Sum": {
        "prefix": "floor_sum",
        "body": [
            "// return floor(a * 0 + b) + floor(a * 1 + b) + ... + floor(a * (n - 1) + b) in O(log(n + m + a + b))",
            "static long floorSum(long n, long m, long a, long b) {",
            "    long res = 0;",
            "    if (a >= m) {",
            "        res += (a / m) * (n - 1) * n / 2;",
            "        a %= m;",
            "    }",
            "    if (b >= m) {",
            "        res += (b / m) * n;",
            "        b %= m;",
            "    }",
            "    long y = (a * n + b) / m, x = y * m - b;",
            "    if (y == 0) return res;",
            "    res += y * (n - (x + a - 1) / a);",
            "    res += floorSum(y, a, m, (a - x % a) % a);",
            "    return res;",
            "}"
        ],
        "description": "Floor Sum"
    },
    "Li-Chao Segment Tree": {
        "prefix": "lichaotree",
        "body": [
            "static class LiChaoTree {",
            "    static class TData {",
            "        long m, c; // y = m * x + c",
            "",
            "        TData() {",
            "            m = Long.MAX_VALUE;",
            "            c = Long.MAX_VALUE;",
            "        }",
            "",
            "        TData(long m, long c) {",
            "            this.m = m;",
            "            this.c = c;",
            "        }",
            "",
            "        long apply(long x) {",
            "            return m * x + c;",
            "        }",
            "    }",
            "",
            "    int n;",
            "    TData[] st;",
            "",
            "    LiChaoTree(int n) {",
            "        this.n = n;",
            "        st = new TData[4 * n];",
            "        for (int i = 0; i < 4 * n; i++) st[i] = new TData();",
            "    }",
            "",
            "    void update(int node, int start, int end, TData y) {",
            "        int mid = (start + end) / 2;",
            "        boolean b1 = y.apply(start) < st[node].apply(start);",
            "        boolean b2 = y.apply(mid) < st[node].apply(mid);",
            "        if (b2) {",
            "            TData temp = st[node];",
            "            st[node] = y;",
            "            y = temp;",
            "        }",
            "        if (start + 1 == end) return;",
            "        if (b1 != b2) update(2 * node, start, mid, y);",
            "        else update(2 * node + 1, mid, end, y);",
            "    }",
            "",
            "    long query(int node, int start, int end, int x) {",
            "        if (start + 1 == end) return st[node].apply(x);",
            "        int mid = (start + end) / 2;",
            "        if (x < mid) return Math.min(st[node].apply(x), query(2 * node, start, mid, x));",
            "        return Math.min(st[node].apply(x), query(2 * node + 1, mid, end, x));",
            "    }",
            "",
            "    void update(TData y) {",
            "        update(1, 0, n, y);",
            "    }",
            "",
            "    long query(int x) {",
            "        return query(1, 0, n, x);",
            "    }",
            "}"
        ],
        "description": "Li-Chao Segment Tree"
    },
	"Li-Chao Dynamic Segment Tree": {
        "prefix": "lichaotree_dynamic",
        "body": [
            "import java.util.*;",
            "",
            "static class LiChaoTree {",
            "    static class Line {",
            "        long m, c;",
            "        Line(long m, long c) { this.m = m; this.c = c; }",
            "        long apply(long x) { return m * x + c; }",
            "    }",
            "    static class Node {",
            "        Line seg;",
            "        Node left, right;",
            "        Node(Line seg) { this.seg = seg; }",
            "    }",
            "    int n;",
            "    Node root;",
            "    static final long INF = 1000000000;",
            "",
            "    LiChaoTree(int n) {",
            "        this.n = n;",
            "        this.root = new Node(new Line(INF, INF));",
            "    }",
            "",
            "    void update(Node node, int start, int end, Line y) {",
            "        int mid = (start + end) / 2;",
            "        boolean b1 = y.apply(start) < node.seg.apply(start);",
            "        boolean b2 = y.apply(mid) < node.seg.apply(mid);",
            "        if (b2) {",
            "            Line temp = node.seg;",
            "            node.seg = y;",
            "            y = temp;",
            "        }",
            "        if (start + 1 == end) return;",
            "        if (b1 != b2) {",
            "            if (node.left == null) node.left = new Node(y);",
            "            else update(node.left, start, mid, y);",
            "        } else {",
            "            if (node.right == null) node.right = new Node(y);",
            "            else update(node.right, mid, end, y);",
            "        }",
            "    }",
            "",
            "    long query(Node node, int start, int end, int x) {",
            "        if (start + 1 == end) return node.seg.apply(x);",
            "        int mid = (start + end) / 2;",
            "        if (x < mid && node.left != null)",
            "            return Math.min(node.seg.apply(x), query(node.left, start, mid, x));",
            "        else if (node.right != null)",
            "            return Math.min(node.seg.apply(x), query(node.right, mid, end, x));",
            "        return node.seg.apply(x);",
            "    }",
            "",
            "    void update(Line y) { update(root, 0, n, y); }",
            "    long query(int x) { return query(root, 0, n, x); }",
            "}"
        ],
        "description": "Li-Chao Dynamic Segment Tree for maintaining minimum values of linear functions over a range"
    },
    "Convex Hull Trick": {
        "prefix": "cht",
        "body": [
            "import java.util.*;",
            "",
            "static class ConvexHullTrick {",
            "    static class Line {",
            "        long m, c;",
            "        Line(long m, long c) { this.m = m; this.c = c; }",
            "        long apply(long x) { return m * x + c; }",
            "    }",
            "    ArrayDeque<Line> dq = new ArrayDeque<>();",
            "",
            "    boolean check(Line p1, Line p2, Line p3) { // p1.m > p2.m > p3.m",
            "        return (p1.m - p2.m) * (p2.c - p3.c) >= (p2.m - p3.m) * (p1.c - p2.c);",
            "    }",
            "",
            "    void add(Line y) { // decreasing slope",
            "        while (dq.size() >= 2) {",
            "            Line p3 = y;",
            "            Line p2 = dq.pollLast();",
            "            Line p1 = dq.peekLast();",
            "            if (p1 != null && check(p1, p2, p3)) dq.offerLast(p2);",
            "            else {",
            "                dq.offerLast(p2);",
            "                break;",
            "            }",
            "        }",
            "        dq.offerLast(y);",
            "    }",
            "",
            "    long query(long x) { // min query, increasing x",
            "        while (dq.size() >= 2 && dq.peekFirst().apply(x) >= dq.getFirst().apply(x))",
            "            dq.pollFirst();",
            "        return dq.peekFirst().apply(x);",
            "    }",
            "",
            "    long queryBinary(long x) { // min query, any x",
            "        int lo = -1, hi = dq.size() - 1;",
            "        while (lo + 1 < hi) {",
            "            int mid = (lo + hi) / 2;",
            "            Line midLine = dq.toArray(new Line[0])[mid];",
            "            Line nextLine = dq.toArray(new Line[0])[mid + 1];",
            "            if (midLine.apply(x) >= nextLine.apply(x)) lo = mid;",
            "            else hi = mid;",
            "        }",
            "        return dq.toArray(new Line[0])[hi].apply(x);",
            "    }",
            "}"
        ],
        "description": "Convex Hull Trick for maintaining minimum values of linear functions"
    },
    "Convex Hull Trick (Fully Dynamic Variant)": {
        "prefix": "cht_dynamic",
        "body": [
            "import java.util.*;",
            "",
            "static class LineContainer {",
            "    static class Line {",
            "        long m, b, p;",
            "        Line(long m, long b) { this.m = m; this.b = b; this.p = 0; }",
            "    }",
            "    TreeSet<Line> lines = new TreeSet<>((a, b) -> Long.compare(a.m, b.m) == 0 ? Long.compare(a.b, b.b) : Long.compare(a.m, b.m));",
            "    static final long INF = Long.MAX_VALUE;",
            "",
            "    long div(long a, long b) { // floored division",
            "        return a / b - ((a ^ b) < 0 && a % b != 0 ? 1 : 0);",
            "    }",
            "",
            "    boolean isect(Iterator<Line> x, Iterator<Line> y) {",
            "        if (!y.hasNext()) { x.next().p = INF; return false; }",
            "        Line xLine = x.next(), yLine = y.next();",
            "        if (xLine.m == yLine.m) xLine.p = xLine.b > yLine.b ? INF : -INF;",
            "        else xLine.p = div(yLine.b - xLine.b, xLine.m - yLine.m);",
            "        return xLine.p >= yLine.p;",
            "    }",
            "",
            "    void add(long m, long b) {",
            "        Line newLine = new Line(m, b);",
            "        lines.add(newLine);",
            "        Iterator<Line> z = lines.tailSet(newLine, true).iterator();",
            "        Line y = z.next();",
            "        Iterator<Line> x = lines.headSet(y, false).iterator();",
            "        while (z.hasNext() && isect(z, z)) lines.remove(z.next());",
            "        if (x.hasNext() && isect(x, lines.tailSet(x.next(), true).iterator())) {",
            "            lines.remove(y);",
            "            isect(x, lines.tailSet(x.next(), true).iterator());",
            "        }",
            "        while (x.hasNext()) {",
            "            Iterator<Line> yIt = lines.tailSet(x.next(), true).iterator();",
            "            Line xLine = yIt.next();",
            "            if (yIt.hasNext() && xLine.p >= yIt.next().p) {",
            "                lines.remove(xLine);",
            "                isect(lines.headSet(xLine, false).iterator(), lines.tailSet(xLine, true).iterator());",
            "            } else break;",
            "        }",
            "    }",
            "",
            "    long query(long x) {",
            "        if (lines.isEmpty()) throw new IllegalStateException(\"LineContainer is empty\");",
            "        Line l = lines.floor(new Line(0, 0) {{ p = x; }});",
            "        return l.m * x + l.b;",
            "    }",
            "}"
        ],
        "description": "Fully dynamic Convex Hull Trick for maintaining minimum values of linear functions"
    },
    "Median Heap": {
        "prefix": "median_heap",
        "body": [
            "import java.util.*;",
            "",
            "static class MedianHeap {",
            "    TreeSet<Integer> lo = new TreeSet<>((a, b) -> a.equals(b) ? 1 : Integer.compare(a, b));",
            "    TreeSet<Integer> hi = new TreeSet<>();",
            "    int k = 100000; // Adjust based on problem constraints",
            "",
            "    void add(int x) {",
            "        int m = lo.isEmpty() ? Integer.MIN_VALUE : lo.last();",
            "        if (x > m) {",
            "            hi.add(x);",
            "            if (hi.size() > k / 2) {",
            "                lo.add(hi.first());",
            "                hi.remove(hi.first());",
            "            }",
            "        } else {",
            "            lo.add(x);",
            "            if (lo.size() > (k + 1) / 2) {",
            "                hi.add(lo.last());",
            "                lo.remove(lo.last());",
            "            }",
            "        }",
            "    }",
            "",
            "    void remove(int x) {",
            "        if (hi.contains(x)) hi.remove(x);",
            "        else lo.remove(x);",
            "        if (lo.isEmpty() && !hi.isEmpty()) {",
            "            lo.add(hi.first());",
            "            hi.remove(hi.first());",
            "        }",
            "    }",
            "}"
        ],
        "description": "Median Heap for maintaining the median of a dynamic set"
    },
    "Z Algorithm": {
        "prefix": "z_algo",
        "body": [
            "import java.util.*;",
            "",
            "static int[] zFunc(String s) {",
            "    int n = s.length();",
            "    int[] f = new int[n]; // f[0] = 0 by default",
            "    for (int i = 1, l = 0, r = 0; i < n; i++) {",
            "        if (i <= r) f[i] = Math.min(r - i + 1, f[i - l]);",
            "        while (i + f[i] < n && s.charAt(f[i]) == s.charAt(i + f[i])) f[i]++;",
            "        if (i + f[i] - 1 > r) { l = i; r = i + f[i] - 1; }",
            "    }",
            "    return f;",
            "}",
            "",
            "static int countOccurrences(String s, String t) {",
            "    String ts = t + \"#\" + s;",
            "    int n = t.length(), nm = ts.length();",
            "    int[] f = zFunc(ts);",
            "    int res = 0;",
            "    for (int i = n + 1; i < nm; i++) if (f[i] == n) res++;",
            "    return res;",
            "}"
        ],
        "description": "Z Algorithm for string matching"
    },
    "Knuth-Morris-Pratt (Prefix Function)": {
        "prefix": "kmp",
        "body": [
            "import java.util.*;",
            "",
            "static int[] prefixFunc(String s) {",
            "    int n = s.length();",
            "    int[] f = new int[n]; // f[0] = 0 by default",
            "    for (int i = 1; i < n; i++) {",
            "        int j = f[i - 1];",
            "        while (j > 0 && s.charAt(i) != s.charAt(j)) j = f[j - 1];",
            "        if (s.charAt(i) == s.charAt(j)) j++;",
            "        f[i] = j;",
            "    }",
            "    return f;",
            "}",
            "",
            "static int countOccurrences(String s, String t) {",
            "    String ts = t + \"#\" + s;",
            "    int n = t.length(), nm = ts.length();",
            "    int[] f = prefixFunc(ts);",
            "    int res = 0;",
            "    for (int i = n + 1; i < nm; i++) if (f[i] == n) res++;",
            "    return res;",
            "}"
        ],
        "description": "Knuth-Morris-Pratt algorithm for string matching"
    },
    "Suffix Array": {
        "prefix": "suffix_array",
        "body": [
            "import java.util.*;",
            "",
            "static class SuffixArray {",
            "    static final int MAX_C = 256;",
            "    int n;",
            "    String s;",
            "    int[] pos, rnk, lcp;",
            "",
            "    SuffixArray(String s) {",
            "        this.n = s.length();",
            "        this.s = s;",
            "        this.pos = new int[n];",
            "        this.rnk = new int[n];",
            "        this.lcp = new int[n];",
            "    }",
            "",
            "    void buildSA() {",
            "        int[] cnt = new int[MAX_C];",
            "        for (int i = 0; i < n; i++) cnt[s.charAt(i)]++;",
            "        for (int i = 1; i < MAX_C; i++) cnt[i] += cnt[i - 1];",
            "        for (int i = n - 1; i >= 0; i--) pos[--cnt[s.charAt(i)]] = i;",
            "        for (int i = 1; i < n; i++) rnk[pos[i]] = rnk[pos[i - 1]] + (s.charAt(pos[i]) != s.charAt(pos[i - 1]) ? 1 : 0);",
            "        for (int k = 0; (1 << k) < n; k++) {",
            "            int[] npos = new int[n], nrnk = new int[n], ncnt = new int[n];",
            "            for (int i = 0; i < n; i++) pos[i] = (pos[i] - (1 << k) + n) % n;",
            "            for (int i = 0; i < n; i++) ncnt[rnk[i]]++;",
            "            for (int i = 1; i < n; i++) ncnt[i] += ncnt[i - 1];",
            "            for (int i = n - 1; i >= 0; i--) npos[--ncnt[rnk[pos[i]]]] = pos[i];",
            "            for (int i = 1; i < n; i++) {",
            "                Pair cur = new Pair(rnk[npos[i]], rnk[(npos[i] + (1 << k)) % n]);",
            "                Pair pre = new Pair(rnk[npos[i - 1]], rnk[(npos[i - 1] + (1 << k)) % n]);",
            "                nrnk[npos[i]] = nrnk[npos[i - 1]] + (cur.equals(pre) ? 0 : 1);",
            "            }",
            "            pos = npos;",
            "            rnk = nrnk;",
            "        }",
            "    }",
            "",
            "    void buildLCP() {",
            "        lcp = new int[n];",
            "        for (int i = 0, k = 0; i < n - 1; i++, k = Math.max(k - 1, 0)) {",
            "            int j = pos[rnk[i] - 1];",
            "            while (i + k < n && j + k < n && s.charAt(i + k) == s.charAt(j + k)) k++;",
            "            lcp[rnk[i]] = k;",
            "        }",
            "    }",
            "",
            "    static class Pair {",
            "        int first, second;",
            "        Pair(int first, int second) { this.first = first; this.second = second; }",
            "        @Override",
            "        public boolean equals(Object o) {",
            "            if (this == o) return true;",
            "            if (o == null || getClass() != o.getClass()) return false;",
            "            Pair pair = (Pair) o;",
            "            return first == pair.first && second == pair.second;",
            "        }",
            "        @Override",
            "        public int hashCode() { return Objects.hash(first, second); }",
            "    }",
            "}"
        ],
        "description": "Suffix Array for string processing"
    },
    "String Hashing": {
        "prefix": "hash",
        "body": [
            "import java.util.*;",
            "import java.time.*;",
            "",
            "static class StringHash {",
            "    static Random rng = new Random(Clock.systemUTC().millis());",
            "    static final int BASE = rng.nextInt(1_000_000_000 - 300 + 1) + 300;",
            "    static final int NUM_MOD = 4;",
            "    static final long[] MODS = {1_000_000_000 + 2277, 1_000_000_000 + 5277, 1_000_000_000 + 8277, 1_000_000_000 + 9277};",
            "    long[][] H, P;",
            "",
            "    StringHash(String s) {",
            "        H = new long[NUM_MOD][s.length() + 1];",
            "        P = new long[NUM_MOD][s.length() + 1];",
            "        for (int i = 0; i < NUM_MOD; i++) {",
            "            P[i][0] = 1;",
            "            H[i][0] = 0;",
            "        }",
            "        for (int j = 0; j < s.length(); j++) {",
            "            for (int i = 0; i < NUM_MOD; i++) {",
            "                P[i][j + 1] = P[i][j] * BASE % MODS[i];",
            "                H[i][j + 1] = (H[i][j] * BASE + s.charAt(j)) % MODS[i];",
            "            }",
            "        }",
            "    }",
            "",
            "    long[] getHash(int l, int r) {",
            "        long[] res = new long[NUM_MOD];",
            "        for (int i = 0; i < NUM_MOD; i++) {",
            "            res[i] = (H[i][r + 1] - H[i][l] * P[i][r + 1 - l]) % MODS[i];",
            "            if (res[i] < 0) res[i] += MODS[i];",
            "        }",
            "        return res;",
            "    }",
            "}"
        ],
        "description": "String Hashing for substring comparison"
    },
    "Lowest Common Ancestor": {
        "prefix": "lca",
        "body": [
            "import java.util.*;",
            "",
            "static class LCA {",
            "    static final int MAX_N = 100005;",
            "    static final int MAX_L = 20;",
            "    int n, q;",
            "    int[][] par = new int[MAX_N][MAX_L];",
            "    int[] dep = new int[MAX_N];",
            "    ArrayList<Integer>[] adj = new ArrayList[MAX_N];",
            "",
            "    LCA(int n) {",
            "        this.n = n;",
            "        for (int i = 0; i < MAX_N; i++) adj[i] = new ArrayList<>();",
            "    }",
            "",
            "    void addEdge(int u, int v) {",
            "        adj[u].add(v);",
            "        adj[v].add(u);",
            "    }",
            "",
            "    void dfs(int u, int p) {",
            "        par[u][0] = p;",
            "        for (int i = 1; i < MAX_L; i++)",
            "            par[u][i] = par[par[u][i - 1]][i - 1];",
            "        for (int v : adj[u]) {",
            "            if (v == p) continue;",
            "            dep[v] = dep[u] + 1;",
            "            dfs(v, u);",
            "        }",
            "    }",
            "",
            "    int ancestor(int u, int k) {",
            "        for (int i = 0; i < MAX_L; i++)",
            "            if ((k & (1 << i)) != 0)",
            "                u = par[u][i];",
            "        return u;",
            "    }",
            "",
            "    int lca(int u, int v) {",
            "        if (dep[u] < dep[v]) { int temp = u; u = v; v = temp; }",
            "        u = ancestor(u, dep[u] - dep[v]);",
            "        if (u == v) return u;",
            "        for (int i = MAX_L - 1; i >= 0; i--)",
            "            if (par[u][i] != par[v][i]) {",
            "                u = par[u][i];",
            "                v = par[v][i];",
            "            }",
            "        return par[u][0];",
            "    }",
            "}"
        ],
        "description": "Lowest Common Ancestor using binary lifting"
    },
    "Dijkstra": {
        "prefix": "dijk",
        "body": [
            "import java.util.*;",
            "",
            "static class Dijkstra {",
            "    static final int MAX_N = 100005;",
            "    static final long INF = 1000000000;",
            "    int n, m;",
            "    ArrayList<int[]>[] adj = new ArrayList[MAX_N];",
            "    long[] dist;",
            "",
            "    Dijkstra(int n) {",
            "        this.n = n;",
            "        for (int i = 0; i < MAX_N; i++) adj[i] = new ArrayList<>();",
            "        dist = new long[n + 1];",
            "    }",
            "",
            "    void addEdge(int u, int v, int w) {",
            "        adj[u].add(new int[]{v, w});",
            "    }",
            "",
            "    void dijkstra(int s) {",
            "        Arrays.fill(dist, INF);",
            "        PriorityQueue<long[]> pq = new PriorityQueue<>((a, b) -> Long.compare(a[0], b[0]));",
            "        dist[s] = 0;",
            "        pq.offer(new long[]{0, s});",
            "        while (!pq.isEmpty()) {",
            "            long[] top = pq.poll();",
            "            long d = top[0];",
            "            int u = (int) top[1];",
            "            if (d > dist[u]) continue;",
            "            for (int[] edge : adj[u]) {",
            "                int v = edge[0], w = edge[1];",
            "                if (dist[v] > dist[u] + w) {",
            "                    dist[v] = dist[u] + w;",
            "                    pq.offer(new long[]{dist[v], v});",
            "                }",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Dijkstra's algorithm for single-source shortest paths"
    },
    "Dijkstra (Dense Graph)": {
        "prefix": "dijk_dense",
        "body": [
            "import java.util.*;",
            "",
            "static class DijkstraDense {",
            "    static final int MAX_N = 100005;",
            "    static final long INF = 1000000000;",
            "    int n, m;",
            "    ArrayList<int[]>[] adj = new ArrayList[MAX_N];",
            "    long[] dist;",
            "",
            "    DijkstraDense(int n) {",
            "        this.n = n;",
            "        for (int i = 0; i < MAX_N; i++) adj[i] = new ArrayList<>();",
            "        dist = new long[n + 1];",
            "    }",
            "",
            "    void addEdge(int u, int v, int w) {",
            "        adj[u].add(new int[]{v, w});",
            "    }",
            "",
            "    void dijkstra(int s) {",
            "        Arrays.fill(dist, INF);",
            "        boolean[] vis = new boolean[n + 1];",
            "        dist[s] = 0;",
            "        for (int i = 0; i < n; i++) {",
            "            int u = -1;",
            "            for (int x = 0; x <= n; x++) {",
            "                if (vis[x]) continue;",
            "                if (u == -1 || dist[x] < dist[u]) u = x;",
            "            }",
            "            if (dist[u] == INF) break;",
            "            vis[u] = true;",
            "            for (int[] edge : adj[u]) {",
            "                int v = edge[0], w = edge[1];",
            "                if (dist[v] > dist[u] + w) dist[v] = dist[u] + w;",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Dijkstra's algorithm for dense graphs"
    },
    "Mo's Algorithm": {
        "prefix": "mo",
        "body": [
            "import java.util.*;",
            "",
            "static class MoAlgorithm {",
            "    static final int MAX_N = 100005;",
            "    static final int SQRT = (int) Math.sqrt(MAX_N);",
            "    int n, q;",
            "    int[] arr = new int[MAX_N], ans = new int[MAX_N], cnt = new int[MAX_N];",
            "    int cur;",
            "    ArrayList<Query> qs = new ArrayList<>();",
            "",
            "    static class Query {",
            "        int l, r, id;",
            "        Query(int l, int r, int id) { this.l = l; this.r = r; this.id = id; }",
            "    }",
            "",
            "    void add(int idx) {",
            "        if (cnt[arr[idx]] == 0) cur++;",
            "        cnt[arr[idx]]++;",
            "    }",
            "",
            "    void subtract(int idx) {",
            "        if (cnt[arr[idx]] == 1) cur--;",
            "        cnt[arr[idx]]--;",
            "    }",
            "",
            "    void compress() {",
            "        TreeMap<Integer, Integer> mp = new TreeMap<>();",
            "        for (int i = 1; i <= n; i++) mp.put(arr[i], i);",
            "        int idx = 1;",
            "        for (Map.Entry<Integer, Integer> entry : mp.entrySet()) {",
            "            mp.put(entry.getKey(), idx++);",
            "        }",
            "        for (int i = 1; i <= n; i++) arr[i] = mp.get(arr[i]);",
            "    }",
            "",
            "    void moAlgo() {",
            "        qs.sort((a, b) -> {",
            "            if (a.l / SQRT == b.l / SQRT) {",
            "                return ((a.l / SQRT) % 2 == 0) ? a.r - b.r : b.r - a.r;",
            "            }",
            "            return a.l - b.l;",
            "        });",
            "        int curL = 0, curR = 0;",
            "        add(0);",
            "        for (Query query : qs) {",
            "            while (curL < query.l) subtract(curL++);",
            "            while (curL > query.l) add(--curL);",
            "            while (curR < query.r) add(++curR);",
            "            while (curR > query.r) subtract(curR--);",
            "            ans[query.id] = cur;",
            "        }",
            "    }",
            "}"
        ],
        "description": "Mo's Algorithm for offline range queries"
    },
    "Treap": {
        "prefix": "treap",
        "body": [
            "import java.util.*;",
            "",
            "static class Treap {",
            "    static Random rng = new Random();",
            "",
            "    static class Node {",
            "        int val, pri, sz;",
            "        Node left, right;",
            "        Node(int val) { this.val = val; this.pri = rng.nextInt(); this.sz = 1; }",
            "    }",
            "",
            "    static int size(Node node) { return node != null ? node.sz : 0; }",
            "",
            "    static void pushDown(Node node) {",
            "        if (node == null) return;",
            "    }",
            "",
            "    static void pullUp(Node node) {",
            "        if (node == null) return;",
            "        pushDown(node.left);",
            "        pushDown(node.right);",
            "        node.sz = size(node.left) + size(node.right) + 1;",
            "    }",
            "",
            "    static void heapify(Node node) {",
            "        if (node == null) return;",
            "        Node mx = node;",
            "        if (node.left != null && node.left.pri > node.pri) mx = node.left;",
            "        if (node.right != null && node.right.pri > node.pri && node.right.pri > mx.pri) mx = node.right;",
            "        if (node != mx) {",
            "            int temp = node.pri;",
            "            node.pri = mx.pri;",
            "            mx.pri = temp;",
            "            heapify(mx);",
            "        }",
            "    }",
            "",
            "    static Node build(int[] arr, int start, int end) {",
            "        if (start > end) return null;",
            "        int mid = (start + end) / 2;",
            "        Node node = new Node(arr[mid]);",
            "        node.left = build(arr, start, mid - 1);",
            "        node.right = build(arr, mid + 1, end);",
            "        heapify(node);",
            "        pullUp(node);",
            "        return node;",
            "    }",
            "",
            "    static void split(Node node, Node[] result, int k) {",
            "        pushDown(node);",
            "        if (node == null) {",
            "            result[0] = result[1] = null;",
            "            return;",
            "        }",
            "        if (size(node.left) >= k) {",
            "            split(node.left, result, k);",
            "            node.left = result[1];",
            "            result[1] = node;",
            "        } else {",
            "            split(node.right, result, k - size(node.left) - 1);",
            "            node.right = result[0];",
            "            result[0] = node;",
            "        }",
            "        pullUp(node);",
            "    }",
            "",
            "    static Node merge(Node left, Node right) {",
            "        pushDown(left);",
            "        pushDown(right);",
            "        if (left == null) return right;",
            "        if (right == null) return left;",
            "        Node node;",
            "        if (left.pri > right.pri) {",
            "            left.right = merge(left.right, right);",
            "            node = left;",
            "        } else {",
            "            right.left = merge(left, right.left);",
            "            node = right;",
            "        }",
            "        pullUp(node);",
            "        return node;",
            "    }",
            "",
            "    static void print(Node node) {",
            "        if (node == null) return;",
            "        print(node.left);",
            "        System.out.print(node.val + \" \");",
            "        print(node.right);",
            "    }",
            "}"
        ],
        "description": "Treap for balanced binary search tree operations"
    },
    "Heavy-Light Decomposition": {
        "prefix": "hld",
        "body": [
            "import java.util.*;",
            "",
            "static class HLD {",
            "    static final int MAX_N = 100005;",
            "    boolean VALS_IN_EDGE;",
            "    int n, timer;",
            "    ArrayList<Integer>[] adj = new ArrayList[MAX_N];",
            "    int[] par, tin, tout, head, dep, sz;",
            "",
            "    HLD(int n, boolean valsInEdge) {",
            "        this.n = n;",
            "        this.VALS_IN_EDGE = valsInEdge;",
            "        par = new int[n];",
            "        tin = new int[n];",
            "        tout = new int[n];",
            "        head = new int[n];",
            "        dep = new int[n];",
            "        sz = new int[n];",
            "        for (int i = 0; i < n; i++) adj[i] = new ArrayList<>();",
            "    }",
            "",
            "    void addEdge(int u, int v) {",
            "        adj[u].add(v);",
            "        adj[v].add(u);",
            "    }",
            "",
            "    void dfsSz(int u) {",
            "        sz[u] = 1;",
            "        for (int i = 0; i < adj[u].size(); i++) {",
            "            int v = adj[u].get(i);",
            "            if (v == par[u]) continue;",
            "            par[v] = u;",
            "            dep[v] = dep[u] + 1;",
            "            dfsSz(v);",
            "            sz[u] += sz[v];",
            "            if (i > 0 && sz[v] > sz[adj[u].get(0)]) {",
            "                int temp = adj[u].get(0);",
            "                adj[u].set(0, v);",
            "                adj[u].set(i, temp);",
            "            }",
            "        }",
            "    }",
            "",
            "    void dfsHld(int u) {",
            "        tin[u] = timer++;",
            "        for (int v : adj[u]) {",
            "            if (v == par[u]) continue;",
            "            head[v] = (v == adj[u].get(0) ? head[u] : v);",
            "            dfsHld(v);",
            "        }",
            "    }",
            "",
            "    void init(int s) {",
            "        par[s] = dep[s] = timer = 0;",
            "        head[s] = s;",
            "        dfsSz(s);",
            "        dfsHld(s);",
            "    }",
            "",
            "    int lca(int u, int v) {",
            "        while (head[u] != head[v]) {",
            "            if (dep[head[u]] > dep[head[v]]) { int temp = u; u = v; v = temp; }",
            "            v = par[head[v]];",
            "        }",
            "        return dep[u] < dep[v] ? u : v;",
            "    }",
            "",
            "    // Note: Requires a SegmentTree class for full functionality",
            "    // void updatePath(int u, int v, int val) {",
            "    //     processPath(u, v, (l, r) -> st.update(l, r, val));",
            "    // }",
            "    // int queryPath(int u, int v) {",
            "    //     int[] res = {0};",
            "    //     processPath(u, v, (l, r) -> res[0] = Math.max(res[0], st.query(l, r).mx));",
            "    //     return res[0];",
            "    // }",
            "}"
        ],
        "description": "Heavy-Light Decomposition for tree path queries (SegmentTree required for full functionality)"
    },
    "Kosaraju's Algorithm": {
        "prefix": "scc",
        "body": [
            "import java.util.*;",
            "",
            "static class Kosaraju {",
            "    static final int MAX_N = 100005;",
            "    int n, m, scc;",
            "    int[] vis = new int[MAX_N], head = new int[MAX_N];",
            "    ArrayList<Integer>[] adj = new ArrayList[MAX_N];",
            "    ArrayList<Integer>[] adjT = new ArrayList[MAX_N];",
            "    ArrayList<Integer>[] comp = new ArrayList[MAX_N];",
            "    ArrayList<Integer> topo = new ArrayList<>();",
            "",
            "    Kosaraju(int n) {",
            "        this.n = n;",
            "        for (int i = 0; i < MAX_N; i++) {",
            "            adj[i] = new ArrayList<>();",
            "            adjT[i] = new ArrayList<>();",
            "            comp[i] = new ArrayList<>();",
            "        }",
            "    }",
            "",
            "    void addEdge(int u, int v) {",
            "        adj[u].add(v);",
            "        adjT[v].add(u);",
            "    }",
            "",
            "    void dfs1(int u) {",
            "        vis[u] = 1;",
            "        for (int v : adj[u]) {",
            "            if (vis[v] == 0) dfs1(v);",
            "        }",
            "        topo.add(u);",
            "    }",
            "",
            "    void dfs2(int u) {",
            "        vis[u] = 1;",
            "        comp[scc].add(u);",
            "        head[u] = scc;",
            "        for (int v : adjT[u]) {",
            "            if (vis[v] == 0) dfs2(v);",
            "        }",
            "    }",
            "",
            "    void kosaraju() {",
            "        Arrays.fill(vis, 0);",
            "        topo.clear();",
            "        for (int i = 1; i <= n; i++) {",
            "            if (vis[i] == 0) dfs1(i);",
            "        }",
            "        Arrays.fill(vis, 0);",
            "        Collections.reverse(topo);",
            "        scc = 0;",
            "        for (int i : topo) {",
            "            if (vis[i] == 0) {",
            "                dfs2(i);",
            "                scc++;",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "Kosaraju's Algorithm for finding strongly connected components"
    },
    "Centroid Decomposition": {
        "prefix": "centroid",
        "body": [
            "import java.util.*;",
            "",
            "static class Centroid {",
            "    int n;",
            "    ArrayList<Integer>[] adj = new ArrayList[100005];",
            "    int[] par = new int[100005], vis = new int[100005], sz = new int[100005];",
            "",
            "    Centroid(int n) {",
            "        this.n = n;",
            "        for (int i = 0; i < 100005; i++) adj[i] = new ArrayList<>();",
            "    }",
            "",
            "    void addEdge(int u, int v) {",
            "        adj[u].add(v);",
            "        adj[v].add(u);",
            "    }",
            "",
            "    int dfsSz(int u, int p) {",
            "        sz[u] = 1;",
            "        for (int v : adj[u]) {",
            "            if (v == p || vis[v] == 1) continue;",
            "            sz[u] += dfsSz(v, u);",
            "        }",
            "        return sz[u];",
            "    }",
            "",
            "    int dfsCentroid(int u, int p) {",
            "        for (int v : adj[u]) {",
            "            if (v == p || vis[v] == 1) continue;",
            "            if (sz[v] > n / 2) return dfsCentroid(v, u);",
            "        }",
            "        return u;",
            "    }",
            "",
            "    void init(int s) {",
            "        n = dfsSz(s, 0);",
            "        int u = dfsCentroid(s, 0);",
            "        vis[u] = 1;",
            "        par[u] = 0;",
            "        for (int v : adj[u]) {",
            "            if (vis[v] == 1) continue;",
            "            init(v);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Centroid Decomposition for tree queries"
    },
    "Linear Diophantine Equation": {
        "prefix": "lde",
        "body": [
            "static long gcd(long a, long b, long[] xy) {",
            "    if (b == 0) { xy[0] = 1; xy[1] = 0; return a; }",
            "    long[] xy1 = new long[2];",
            "    long d = gcd(b, a % b, xy1);",
            "    xy[0] = xy1[1];",
            "    xy[1] = xy1[0] - xy1[1] * (a / b);",
            "    return d;",
            "}",
            "",
            "static boolean lde(long a, long b, long c, long[] xy) {",
            "    long d = gcd(Math.abs(a), Math.abs(b), xy);",
            "    if (c % d != 0) return false;",
            "    xy[0] *= c / d;",
            "    xy[1] *= c / d;",
            "    if (a < 0) xy[0] = -xy[0];",
            "    if (b < 0) xy[1] = -xy[1];",
            "    return true;",
            "}",
            "",
            "static void shift(long a, long b, long[] xy, long cnt) {",
            "    xy[0] += cnt * b;",
            "    xy[1] -= cnt * a;",
            "}"
        ],
        "description": "Linear Diophantine Equation solver"
    },
    "Linear Congruence Equation": {
        "prefix": "lce",
        "body": [
            "static long gcd(long a, long b, long[] xy) {",
            "    if (b == 0) { xy[0] = 1; xy[1] = 0; return a; }",
            "    long[] xy1 = new long[2];",
            "    long d = gcd(b, a % b, xy1);",
            "    xy[0] = xy1[1];",
            "    xy[1] = xy1[0] - xy1[1] * (a / b);",
            "    return d;",
            "}",
            "",
            "static long invMod(long a, long m) {",
            "    long[] xy = new long[2];",
            "    gcd(a, m, xy);",
            "    return (m + xy[0] % m) % m;",
            "}",
            "",
            "static long lce(long a, long b, long m) {",
            "    long d = gcd(a, m, new long[2]);",
            "    if (d != 1) {",
            "        if (b % d != 0) return -1;",
            "        a /= d; b /= d; m /= d;",
            "    }",
            "    return (b * invMod(a, m) % m + m) % m;",
            "}"
        ],
        "description": "Linear Congruence Equation solver"
    },
    "Compress Coordinates": {
        "prefix": "compress",
        "body": [
            "import java.util.*;",
            "",
            "static void compress(int[] a, int n) {",
            "    Integer[] b = new Integer[n];",
            "    for (int i = 0; i < n; i++) b[i] = a[i];",
            "    Arrays.sort(b);",
            "    int size = 1;",
            "    for (int i = 1; i < n; i++) if (!b[i].equals(b[i - 1])) b[size++] = b[i];",
            "    for (int i = 0; i < n; i++) {",
            "        a[i] = Arrays.binarySearch(b, 0, size, a[i]);",
            "    }",
            "}"
        ],
        "description": "Compress coordinates to map values to smaller indices"
    },
    "DFS": {
        "prefix": "dfs",
        "body": [
            "import java.util.*;",
            "",
            "static class DFS {",
            "    static final int MAX_N = 100005;",
            "    int n;",
            "    ArrayList<Integer>[] adj = new ArrayList[MAX_N];",
            "",
            "    DFS(int n) {",
            "        this.n = n;",
            "        for (int i = 0; i < MAX_N; i++) adj[i] = new ArrayList<>();",
            "    }",
            "",
            "    void addEdge(int u, int v) {",
            "        adj[u].add(v);",
            "        adj[v].add(u);",
            "    }",
            "",
            "    void dfs(int u, int p) {",
            "        for (int v : adj[u]) {",
            "            if (v == p) continue;",
            "            dfs(v, u);",
            "        }",
            "    }",
            "",
            "    void solve(Scanner sc) {",
            "        n = sc.nextInt();",
            "        for (int i = 0; i < n - 1; i++) {",
            "            int u = sc.nextInt(), v = sc.nextInt();",
            "            addEdge(u, v);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Depth-First Search for tree traversal"
    },
    "Sack (DSU on Tree)": {
        "prefix": "sack",
        "body": [
            "import java.util.*;",
            "",
            "static class Sack {",
            "    static final int MAX_N = 100005;",
            "    int n;",
            "    int[] sz = new int[MAX_N];",
            "    ArrayList<Integer>[] adj = new ArrayList[MAX_N];",
            "    ArrayList<Integer>[] vec = new ArrayList[MAX_N];",
            "",
            "    Sack(int n) {",
            "        this.n = n;",
            "        for (int i = 0; i < MAX_N; i++) {",
            "            adj[i] = new ArrayList<>();",
            "            vec[i] = new ArrayList<>();",
            "        }",
            "    }",
            "",
            "    void addEdge(int u, int v) {",
            "        adj[u].add(v);",
            "        adj[v].add(u);",
            "    }",
            "",
            "    void dfsSz(int u, int p) {",
            "        sz[u] = 1;",
            "        for (int v : adj[u]) {",
            "            if (v == p) continue;",
            "            dfsSz(v, u);",
            "            sz[u] += sz[v];",
            "        }",
            "    }",
            "",
            "    void update(int u, int x) {",
            "        // Implement node update logic here",
            "    }",
            "",
            "    void dfs(int u, int p, boolean keep) {",
            "        int hvVal = -1, hv = -1;",
            "        for (int v : adj[u]) {",
            "            if (v == p) continue;",
            "            if (sz[v] > hvVal) { hvVal = sz[v]; hv = v; }",
            "        }",
            "        for (int v : adj[u]) {",
            "            if (v == p || v == hv) continue;",
            "            dfs(v, u, false);",
            "        }",
            "        if (hv != -1) {",
            "            dfs(hv, u, true);",
            "            ArrayList<Integer> temp = vec[u];",
            "            vec[u] = vec[hv];",
            "            vec[hv] = temp;",
            "        }",
            "        vec[u].add(u);",
            "        update(u, 1);",
            "        for (int v : adj[u]) {",
            "            if (v == p || v == hv) continue;",
            "            for (int x : vec[v]) {",
            "                update(x, 1);",
            "                vec[u].add(x);",
            "            }",
            "        }",
            "        // Process queries for node u here",
            "        if (!keep) {",
            "            for (int v : vec[u]) update(v, -1);",
            "        }",
            "    }",
            "}"
        ],
        "description": "Sack (DSU on Tree) for subtree queries"
    },
    "Euler Circuit Undirected (Hierholzer’s Algorithm)": {
        "prefix": "euler_undirected",
        "body": [
            "import java.util.*;",
            "",
            "static class EulerCircuit {",
            "    static final int MAX_N = 100005;",
            "    int n, m;",
            "    HashSet<Integer>[] adj = new HashSet[MAX_N];",
            "",
            "    EulerCircuit(int n, int m) {",
            "        this.n = n;",
            "        this.m = m;",
            "        for (int i = 0; i < MAX_N; i++) adj[i] = new HashSet<>();",
            "    }",
            "",
            "    void addEdge(int u, int v) {",
            "        adj[u].add(v);",
            "        adj[v].add(u);",
            "    }",
            "",
            "    void euler(PrintWriter out) {",
            "        for (int i = 1; i <= n; i++) {",
            "            if (adj[i].size() % 2 != 0) {",
            "                out.println(\"IMPOSSIBLE\");",
            "                return;",
            "            }",
            "        }",
            "        ArrayList<Integer> res = new ArrayList<>();",
            "        Stack<Integer> st = new Stack<>();",
            "        st.push(1);",
            "        while (!st.isEmpty()) {",
            "            int u = st.peek();",
            "            if (adj[u].isEmpty()) {",
            "                res.add(u);",
            "                st.pop();",
            "            } else {",
            "                int v = adj[u].iterator().next();",
            "                adj[u].remove(v);",
            "                adj[v].remove(u);",
            "                st.push(v);",
            "            }",
            "        }",
            "        if (res.size() != m + 1) {",
            "            out.println(\"IMPOSSIBLE\");",
            "            return;",
            "        }",
            "        for (int u : res) out.print(u + \" \");",
            "        out.println();",
            "    }",
            "",
            "    void solve(Scanner sc, PrintWriter out) {",
            "        n = sc.nextInt();",
            "        m = sc.nextInt();",
            "        for (int i = 0; i < m; i++) {",
            "            int u = sc.nextInt(), v = sc.nextInt();",
            "            addEdge(u, v);",
            "        }",
            "        euler(out);",
            "    }",
            "}"
        ],
        "description": "Euler Circuit for undirected graphs using Hierholzer’s Algorithm"
    },
    "Euler Path Directed (Hierholzer’s Algorithm)": {
        "prefix": "euler_directed",
        "body": [
            "import java.util.*;",
            "",
            "static class EulerPathDirected {",
            "    static final int MAX_N = 100005;",
            "    int n, m;",
            "    int[] inDeg = new int[MAX_N], outDeg = new int[MAX_N];",
            "    ArrayList<Integer>[] adj = new ArrayList[MAX_N];",
            "",
            "    EulerPathDirected(int n, int m) {",
            "        this.n = n;",
            "        this.m = m;",
            "        for (int i = 0; i < MAX_N; i++) adj[i] = new ArrayList<>();",
            "    }",
            "",
            "    void addEdge(int u, int v) {",
            "        adj[u].add(v);",
            "        outDeg[u]++;",
            "        inDeg[v]++;",
            "    }",
            "",
            "    void euler(PrintWriter out) {",
            "        if (outDeg[1] != inDeg[1] + 1 || inDeg[n] != outDeg[n] + 1) {",
            "            out.println(\"IMPOSSIBLE\");",
            "            return;",
            "        }",
            "        for (int i = 2; i < n; i++) {",
            "            if (inDeg[i] != outDeg[i]) {",
            "                out.println(\"IMPOSSIBLE\");",
            "                return;",
            "            }",
            "        }",
            "        ArrayList<Integer> res = new ArrayList<>();",
            "        Stack<Integer> st = new Stack<>();",
            "        st.push(1);",
            "        while (!st.isEmpty()) {",
            "            int u = st.peek();",
            "            if (adj[u].isEmpty()) {",
            "                res.add(u);",
            "                st.pop();",
            "            } else {",
            "                int v = adj[u].remove(adj[u].size() - 1);",
            "                st.push(v);",
            "            }",
            "        }",
            "        if (res.size() != m + 1) {",
            "            out.println(\"IMPOSSIBLE\");",
            "            return;",
            "        }",
            "        Collections.reverse(res);",
            "        for (int u : res) out.print(u + \" \");",
            "        out.println();",
            "    }",
            "",
            "    void solve(Scanner sc, PrintWriter out) {",
            "        n = sc.nextInt();",
            "        m = sc.nextInt();",
            "        for (int i = 0; i < m; i++) {",
            "            int u = sc.nextInt(), v = sc.nextInt();",
            "            addEdge(u, v);",
            "        }",
            "        euler(out);",
            "    }",
            "}"
        ],
        "description": "Euler Path for directed graphs using Hierholzer’s Algorithm"
    },
    "Geometry (KACTL Library)": {
        "prefix": "point",
        "body": [
            "import java.util.*;",
            "",
            "static class Point<T extends Number> {",
            "    T x, y;",
            "",
            "    Point() { this.x = (T) Long.valueOf(0); this.y = (T) Long.valueOf(0); }",
            "    Point(T x, T y) { this.x = x; this.y = y; }",
            "",
            "    Point<T> add(Point<T> p) {",
            "        return new Point<>((T) Long.valueOf(x.longValue() + p.x.longValue()), (T) Long.valueOf(y.longValue() + p.y.longValue()));",
            "    }",
            "",
            "    Point<T> subtract(Point<T> p) {",
            "        return new Point<>((T) Long.valueOf(x.longValue() - p.x.longValue()), (T) Long.valueOf(y.longValue() - p.y.longValue()));",
            "    }",
            "",
            "    Point<T> multiply(T d) {",
            "        return new Point<>((T) Long.valueOf(x.longValue() * d.longValue()), (T) Long.valueOf(y.longValue() * d.longValue()));",
            "    }",
            "",
            "    Point<T> divide(T d) {",
            "        return new Point<>((T) Long.valueOf(x.longValue() / d.longValue()), (T) Long.valueOf(y.longValue() / d.longValue()));",
            "    }",
            "",
            "    long dot(Point<T> p) {",
            "        return x.longValue() * p.x.longValue() + y.longValue() * p.y.longValue();",
            "    }",
            "",
            "    long cross(Point<T> p) {",
            "        return x.longValue() * p.y.longValue() - y.longValue() * p.x.longValue();",
            "    }",
            "",
            "    long cross(Point<T> a, Point<T> b) {",
            "        return subtract(a).cross(subtract(b));",
            "    }",
            "",
            "    long dist2() {",
            "        return x.longValue() * x.longValue() + y.longValue() * y.longValue();",
            "    }",
            "",
            "    double dist() {",
            "        return Math.sqrt(dist2());",
            "    }",
            "",
            "    double angle() {",
            "        return Math.atan2(y.longValue(), x.longValue());",
            "    }",
            "",
            "    Point<Double> unit() {",
            "        double d = dist();",
            "        return new Point<>(x.doubleValue() / d, y.doubleValue() / d);",
            "    }",
            "",
            "    Point<Long> perp() {",
            "        return new Point<>(-y.longValue(), x.longValue());",
            "    }",
            "",
            "    Point<Double> normal() {",
            "        return unit().perp();",
            "    }",
            "",
            "    Point<Double> rotate(double a) {",
            "        return new Point<>(x.doubleValue() * Math.cos(a) - y.doubleValue() * Math.sin(a),",
            "                          x.doubleValue() * Math.sin(a) + y.doubleValue() * Math.cos(a));",
            "    }",
            "",
            "    @Override",
            "    public String toString() {",
            "        return \"(\" + x + \",\" + y + \")\";",
            "    }",
            "",
            "    @Override",
            "    public boolean equals(Object o) {",
            "        if (this == o) return true;",
            "        if (o == null || getClass() != o.getClass()) return false;",
            "        Point<?> point = (Point<?>) o;",
            "        return x.equals(point.x) && y.equals(point.y);",
            "    }",
            "",
            "    @Override",
            "    public int hashCode() { return Objects.hash(x, y); }",
            "}",
            "",
            "static class PointL extends Point<Long> {",
            "    PointL(long x, long y) { super(x, y); }",
            "}"
        ],
        "description": "Geometry utilities for points with operations (KACTL library)"
    },
    "Unordered Hash": {
        "prefix": "unordered_hash",
        "body": [
            "import java.util.*;",
            "",
            "static class CustomHash {",
            "    static long splitmix64(long x) {",
            "        x += 0x9e3779b97f4a7c15L;",
            "        x = (x ^ (x >>> 30)) * 0xbf58476d1ce4e5b9L;",
            "        x = (x ^ (x >>> 27)) * 0x94d049bb133111ebL;",
            "        return x ^ (x >>> 31);",
            "    }",
            "",
            "    static long hash(long x) {",
            "        return splitmix64(x + System.nanoTime());",
            "    }",
            "}"
        ],
        "description": "Custom hash for unordered collections"
    }
}